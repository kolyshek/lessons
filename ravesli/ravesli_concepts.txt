Компьютерная программа
Cтейтмент
Выражение
Функция
Библиотека
Комментарий
Однострочные комментарии
Многострочные комментарии
Закомментировать код
Объект
l-value
r-value
Вызов функции
Caller
Вызываемая функция
Параметр функции
Аргумент функции
Передача по значению
Рефакторинг кода
Идентификатор
CamelCase
Литерал
Операнд
Определение
Объявление
Директивы
Макрос
Header guards
Отладчик
Степпинг
Точки останова
Отслеживание переменных
Стек вызовов
Переменные
Бит
Копирующая инициализация
Прямая инициализация
Signed
Unsigned
Переполнение
Логические переменные
ASCII
Строка
Литеральные константы
Магическое число
Время компиляции
Время выполнения программы
Унарные операторы
Бинарные операторы
Условный (тернарный) оператор
Эпсилон
Побитовое исключающее ИЛИ (XOR)
Битовая маска
Блоки стейтментов
Уровень вложенности функции
Область видимости
Продолжительность жизни
Перечисление
Пользовательские типы данных
Спагетти-код
Счетчик цикла
Генератор псевдослучайных чисел
Буфер данных
Тестирование программного обеспечения
Покрытие стейтментов
Массив
Сортировка массива
Нуль-терминатор
Указатель
Разыменованный указатель
Нулевое значение
Указатель на константное значение
Константный указатель
Ссылка
Указатель типа void
Итератор
Распараллеливание
Инспекторы
Мутаторы
Фасилитаторы
Перегрузка функций
Параметр по умолчанию
Стек
Рекурсивная функция
Условие завершения рекурсии
Базовый случай
Безопасное программирование
Аргументы командной строки
argc
argv
Лямбда-выражение
Функторы
Открытые члены
Закрытые члены
Инкапсуляция
Функция доступа
Геттеры
Сеттеры
Конструктор
Деструктор
Идиома RAII
Указатель *this
Константный метод
Дружественная функция
Анонимный объект
Функторы
Конструктор копирования
Контейнерный класс
Контейнеры значения
Контейнеры ссылки
Таблица поиска
Виртуальная функция в языке С++
Связывание
Прямой вызов функции
Раннее связывание
Позднее связывание
Виртуальная таблица в языке С++
Интерфейс
Виртуальный базовый класс
Шаблоны функций
Параметр non-type в шаблоне
Спецификации исключений
Класс-Исключение
Умный указатель
Циклическая зависимость
Последовательные контейнеры
Ассоциативные контейнеры
Адаптеры
Итератор
Поток
Стандартный поток
Манипулятор
Группа форматирования
Валидация пользовательского ввода
Статическая библиотека
Динамическая библиотека
Библиотека импорта
Спецификации исключений
Гарантии безопасности исключений
Структуры данных
Алгоритм
Сеть
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Компьютерная программа — это последовательность инструкций, которые сообщают компьютеру, что ему нужно сделать.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Cтейтмент (англ. «statement») — это наиболее распространенный тип инструкций в программах. Это и есть та самая
инструкция, наименьшая независимая единица в языке С++. Стейтмент в программировании — это то же самое, что и
«предложение» в русском языке. Мы пишем предложения, чтобы выразить какую-то идею. В языке C++ мы пишем
стейтменты, чтобы выполнить какое-то задание. Все стейтменты в языке C++ заканчиваются точкой с запятой.

Примеры:
int х — это стейтмент объявления (англ. «statement declaration»).
х = 5 — это стейтмент присваивания (англ. «assignment statement»).
std::cout << x; — это стейтмент вывода (англ. «output statement»).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Выражение (англ. «expression») — это математический объект, который создается (составляется) для проведения вычислений
и нахождения соответствующего результата. Например, в математике выражение 2 + 3 имеет значение 5.

Выражения в языке С++ могут содержать:
Отдельные цифры и числа (например, 2, 45);
Буквенные переменные (например, х, у);
Операторы, в т.ч. математические (например, +, -);
Функции.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Функция — это последовательность стейтментов. Каждая программа, написанная на языке C++, должна содержать главную
функцию main(). Именно с первого стейтмента, находящегося в функции main(), и начинается выполнение всей программы.
Функции, как правило, выполняют конкретное задание. Например, функция max() может содержать стейтменты, которые определяют
большее из заданных чисел, а функция calculateGrade() может вычислять среднюю оценку студента по какой-либо дисциплине.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Библиотека — это набор скомпилированного кода (например, функций), который был «упакован» для повторного
использования в других программах. С помощью библиотек можно расширить возможности программ. Например, если вы
пишете игру, то вам придется подключать библиотеки звука или графики (если вы самостоятельно не хотите их создавать).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Комментарий — это строка (или несколько строк) текста, которая вставляется в исходный код для объяснения того, что
делает код. В языке C++ есть 2 типа комментариев: однострочные и многострочные.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Однострочные комментарии — это комментарии, которые пишутся после символов //. Они пишутся в отдельных
строках и всё, что находится после этих символов комментирования, — игнорируется компилятором.

Пример:
std::cout << «Hello, world!» << std::endl; // всё, что находится справа от двойного слеша, - игнорируется компилятором
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Многострочные комментарии — это комментарии, которые пишутся между символами /* */. Всё, что находится между
звёздочками, — игнорируется компилятором.

Пример:
/* Это многострочный комментарий.
Эта строка игнорируется
и эта тоже. */
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Закомментировать код — это конвертировать одну или несколько строк кода в комментарии. Таким образом, вы можете
(временно) исключить часть кода из компиляции.

Не закомментировано:
std::cout << 1;

Закомментировано:
//std::cout << 1;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Объект — это часть памяти, которая может хранить значение. В качестве аналогии мы можем использовать почтовый ящик,
куда мы помещаем информацию и откуда её извлекаем. Все компьютеры имеют оперативную память, которую используют программы.
При создании объекта, часть оперативной памяти выделяется для этого объекта.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
l-value (в переводе «л-значение», произносится как «ел-валью») — это значение, которое
имеет свой собственный адрес в памяти.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
r-value (в переводе «р-значение», произносится как «ер-валью») — это значение, которое
не имеет постоянного адреса в памяти.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Вызов функции — это выражение, которое указывает процессору прервать выполнение
текущей функции и приступить к выполнению другой функции.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Caller — функция, в которой находится вызов другой функции.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Вызываемая функция — функция, которую вызывают.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Параметр функции — это переменная, которая используется в функции, и значение которой предоставляет caller
(вызывающий объект). Параметры указываются при объявлении функции в круглых скобках. Если их много, то они
перечисляются через запятую.

Пример:
int add(int a, int b)
{
   return a + b;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Аргумент функции — это значение, которое передается из caller-а в функцию и которое указывается в
скобках при вызове функции в caller-е.

Пример:
printValue(7); // 7 – это аргумент функции printValue()
add(4, 5); // 4 и 5 – это аргументы функции add()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Передача по значению — это когда все параметры функции, при её вызове, создаются как локальные переменные,
а значение каждого из аргументов копируется в соответствующий параметр (локальную переменную).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Рефакторинг кода — Это разбитие слишком больших, сложных или непонятных функций на несколько подфункций.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Идентификатор — это имя переменной, функции, класса или другого объекта в языке C++. Мы можем определять
идентификаторы любыми словами/именами. Тем не менее, есть несколько общих правил, которые необходимо соблюдать:

=> Идентификатор не может быть ключевым словом. Ключевые слова зарезервированы.

=>Идентификатор может состоять только из букв (нижнего и верхнего регистра) латинского алфавита, цифр и символов
подчёркивания. Это означает, что все другие символы и пробелы — запрещены.

=>Идентификатор должен начинаться с буквы (нижнего или верхнего регистра). Он не может начинаться с цифры.

=>Язык C++ различает нижний регистр от верхнего. nvalue отличается от nValue и отличается от NVALUE.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CamelCase (в переводе как «ВерблюжийСтиль») — принцип, когда несколько слов пишутся слитно, без пробелов, и
каждое новое слово пишется с заглавной буквы.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Литерал — это фиксированное значение, которое записывается непосредственно в исходном коде (например, 7 или 3.14159).

Пример:
int a = 3; // a – это переменная, 3 – это литерал
std::cout << 5 + 2; // 5 + 2 – это выражение, 5 и 2 – это литералы
std::cout << "Hello, world!"; // "Hello, world" – это тоже литерал
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Операнд — это данные, с которыми работает выражение.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Определение — это фактическая реализация (вызов выделения памяти) идентификатора.

Пример:
int add(int x, int y) // определяем функцию add()
{
    int z = x + y; // определяем переменную z
 
    return z;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Объявление — это стейтмент, который сообщает компилятору о существовании идентификатора и о его типе.

Пример:
// сообщаем компилятору о функции add(), которая имеет два параметра типа int и возвращает целочисленное значение
int add(int x, int y);

// объявляем целочисленную переменную х
int x;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Директивы — это специальные команды, которые начинаются с символа # и НЕ заканчиваются точкой с запятой.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Макрос — это правило, которое определяет конвертацию идентификатора в указанные данные.Есть два основных типа
макросов: макросы-функции и макросы-объекты.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Header guards — это директивы условной компиляции.

Пример:
#ifndef SOME_UNIQUE_NAME_HERE
#define SOME_UNIQUE_NAME_HERE
 
// Основная часть кода 
 
#endif
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Отладчик (или «дебаггер», от англ. «debugger») — это компьютерная программа, которая позволяет программисту
контролировать выполнение кода. Например, программист может использовать отладчик для выполнения программы
пошагово, последовательно изучая значения переменных в программе.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Степпинг (англ. «stepping») — это возможность отладчика выполнять код пошагово (строка за строкой).

Команды степпинга:
Команда "Шаг с заходом"
Команда "Шаг с обходом"
Команда "Шаг с выходом"

Команда «Шаг с заходом» (англ. «Step into») выполняет следующую строку кода. Если этой строкой является вызов
функции, то «Шаг с заходом» открывает функцию и выполнение переносится в начало этой функции.

Команда «Шаг с обходом» (англ. «Step over») позволяет выполнить следующую строку кода. Только если этой
строкой является вызов функции, то «Шаг с обходом» выполнит весь код функции в одно нажатие и возвратит
нам контроль после того, как функция будет выполнена.

команда «Шаг с выходом» (англ. «Step out») не просто выполняет следующую строку кода. Она выполняет весь оставшийся
код функции, в которой вы сейчас находитесь, и возвращает контроль только после того, когда функция завершит свое
выполнение. Проще говоря, «Шаг с выходом» позволяет выйти из функции.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Точки останова (англ. «breakpoints») — это специальные маркеры, на которых отладчик останавливает процесс выполнения программы.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Отслеживание переменных — это процесс проверки значений переменных во время отладки.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Стек вызовов — это список всех активных функций, которые вызывались до текущего местоположения. В стек вызовов
записывается вызываемая функция и выполняемая строка. Всякий раз, когда происходит вызов новой функции, эта новая
функция добавляется в верх стека. Когда выполнение текущей функции прекращается, она удаляется из верхней части
стека и управление переходит к функции ниже (второй по счету).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Переменные — это имена кусочков памяти, которые могут хранить информацию. Помним, что компьютеры имеют оперативную
память, которая доступна программам для использования. Когда мы определяем переменную, часть этой памяти отводится ей.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Бит (англ. «bit« от «binary digit») — это наименьшая единица памяти, которая может содержать либо значение 0, либо значение 1.
Вы можете думать о бите, как о переключателе света — либо свет выключен (0), либо включен (1). Чего-то среднего между ними нет.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Копирующая инициализация (или «инициализация копированием») — это инициализация с помощью знака равенства =.

Пример:
int nValue = 5; // копирующая инициализация
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Прямая инициализация — это инициализация с помощью круглых скобок ().

Пример:
int nValue(5); // прямая инициализация
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Signed (со знаком) означает, что переменная может содержать как положительные, так и отрицательные числа.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Unsigned (без знака) может содержать только положительные числа.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Переполнение (англ. «overflow») случается при потере бит из-за того, что переменной не было
выделено достаточно памяти для их хранения.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Логические переменные — это переменные, диапазон которых состоит только из двух возможный значений: true (1) и false (0).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ASCII (сокр. от «American Standard Code for Information Interchange») — это американский стандартный код для обмена
информацией, который определяет способ представления символов английского языка (+ несколько других) в виде чисел
от 0 до 127. Например: код буквы 'а' — 97, код буквы 'b' — 98.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Строка (тип string) — это набор последовательных символов.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Литеральные константы (или просто «литералы») — это значения, которые вставляются непосредственно в код.
Поскольку они являются константами, то их значения изменить нельзя.

Пример:
bool myNameIsAlex = true; // true - это литеральная константа типа bool
int x = 5; // 5 - это литеральная константа типа int
int y = 2 * 3; // 2 и 3 - это литеральные константы типа int
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Магическое число — это хорошо закодированный литерал (обычно, число) в строке кода, который не имеет никакого контекста.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Когда вы находитесь в процессе компиляции программы, то это время компиляции (англ. «compile time»). Компилятор
проверяет вашу программу на синтаксические ошибки и, если их нет, конвертирует код в объектные файлы.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Временной промежуток с момента старта выполнения программы и до момента окончания её работы называется
временем выполнения программы (англ. «runtime»). Код выполняется строка за строкой.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Унарные операторы — это операторы, которые применяются только к одному операнду.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Бинарные операторы — это операторы, которые применяются к двум операндам (слева и справа). Существует 5 бинарных операторов.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Условный (тернарный) оператор (обозначается как ?:) является единственным тернарным оператором в языке С++, который работает
с 3-мя операндами. Из-за этого его часто называют просто «тернарный оператор».
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Эпсилон — это значение, используемое для представления термина «достаточно близки», называется.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Побитовое исключающее ИЛИ (XOR) — это логический оператор, который используется в некоторых языках программирования для
проверки на истинность нечётного количества условий.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Битовая маска — это когда мы соединяем отдельные биты вместе, в целях их модификации как группы.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Блоки стейтментов (или «составные операторы») — это группа стейтментов, которые обрабатываются компилятором
как одна инструкция. Блок начинается с символа { и заканчивается символом }, стейтменты находятся внутри. Блоки
могут использоваться в любом месте, где разрешено использовать один стейтмент. В конце составного оператора точка с
запятой не ставится.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Уровень вложенности функции (или «глубина вложенности функции») — это максимальное количество блоков, которые могут
находиться в любой точке функции (включая внешний блок).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Область видимости определяет, где можно использовать переменную.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Продолжительность жизни (или «время жизни») определяет, где переменная создается и где уничтожается.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Перечисление (или «перечисляемый тип») — это тип данных, где любое значение (или «перечислитель»)
определяется как символьная константа.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Пользовательские типы данных — типы, которые группируют несколько отдельных переменных вместе.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Спагетти-код — это код, порядок выполнения которого напоминает тарелку со спагетти (всё запутано и закручено), что крайне
затрудняет следование порядку и понимание логики выполнения такого кода.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Счетчик цикла — это целочисленная переменная, которая объявляется с единственной целью: считать, сколько раз выполнился цикл.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Генератор псевдослучайных чисел (сокр. «ГПСЧ») — это программа, которая принимает стартовое/начальное значение и выполняет с
ним определенные математические операции, чтобы конвертировать его в другое число, которое совсем не связано со стартовым.
Затем программа использует новое сгенерированное значение и выполняет с ним те же математические операции, что и с начальным
числом, чтобы конвертировать его в еще одно новое число — третье, которое не связано ни с первым, ни со вторым. Применяя этот
алгоритм к последнему сгенерированному значению, программа может генерировать целый ряд новых чисел, которые будут казаться
случайными (при условии, что алгоритм будет достаточно сложным).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Буфер данных — это часть памяти, зарезервированная для временного хранения данных, когда они
перемещаются из одного места в другое.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Тестирование программного обеспечения — это процесс определения работоспособности программного
обеспечения согласно ожиданиям разработчика.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Покрытие стейтментов — это процент стейтментов в вашем коде, которые были задействованы во время выполнения тестирования.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Массив — совокупный тип данных, который позволяет получить доступ ко всем переменным одного и
того же типа данных через использование одного идентификатора.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Сортировка массива — это процесс распределения всех элементов массива в определенном порядке.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Нуль-терминатор — это специальный символ (ASCII-код которого равен 0), используемый для обозначения конца строки.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Указатель — это переменная, значением которой является адрес ячейки памяти.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Разыменованный указатель — это содержимое ячейки памяти, на которую он указывает
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Нулевое значение (или «значение null») — это специальное значение, которое означает, что указатель ни на что не указывает.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Указатель на константное значение — это неконстантный указатель, который указывает на неизменное значение.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Константный указатель — это указатель, значение которого не может быть изменено после инициализации.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Ссылка — это тип переменной в языке C++, который работает как псевдоним другого объекта или значения.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Указатель типа void (или «общий указатель») — это специальный тип указателя,
который может указывать на объекты любого типа данных!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Итератор — это объект, разработанный специально для перебора элементов контейнера (например, значений массива или
символов в строке), обеспечивающий во время перемещения по элементам доступ к каждому из них.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Распараллеливание — возможность выделять несколько потоков ЦП для одной и той же задачи, чтобы выполнить её быстрее.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Инспекторы — используются для просмотра (без изменений) данных в контейнере (например, операции поиска или подсчета элементов).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Мутаторы — используются для изменения данных в контейнере (например, операции сортировки или перестановки элементов).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Фасилитаторы — используются для генерации результата на основе значений элементов данных (например, объекты, которые умножают
значения, либо объекты, которые определяют, в каком порядке пары элементов должны быть отсортированы).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Перегрузка функций — это возможность определять несколько функций с одним и тем же именем, но с разными параметрами.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Параметр по умолчанию (или «необязательный параметр») — это параметр функции,
который имеет определенное (по умолчанию) значение.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Стек — это структура данных типа LIFO (англ. «Last In, First Out» = «Последним пришел, первым ушел»).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Рекурсивная функция (или просто «рекурсия») в языке C++ — это функция, которая вызывает сама себя.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Условие завершения рекурсии — это условие, которое, при его выполнении, остановит вызов рекурсивной функции самой себя.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Базовый случай — это когда алгоритм при определенных данных ввода производит предсказуемые данные вывода.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Безопасное программирование — это методика разработки программ, которая включает анализ областей, где могут быть допущены
ложные предположения, и написание кода, который обнаруживает и обрабатывает любой случай такого нарушения,
чтобы свести к минимуму риск возникновения сбоя или повреждения программы.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Аргументы командной строки — это необязательные строковые аргументы,
передаваемые операционной системой в программу при её запуске.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
argc (англ. «argument count» = «количество аргументов») — это целочисленный параметр, содержащий количество аргументов,
переданных в программу. argc всегда будет как минимум один, так как первым аргументом всегда является имя самой программы.
Каждый аргумент командной строки, который предоставляет пользователь, заставит argc увеличиться на единицу.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
argv (англ. «argument values» = «значения аргументов») — это место, где хранятся фактические значения аргументов.
Хотя объявление argv выглядит немного пугающе, но это всего лишь массив строк C-style. Длиной этого массива является argc.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Лямбда-выражение (или просто «лямбда») в программировании позволяет определить анонимную функцию внутри другой функции.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Функторы — это объекты, содержащие перегруженный operator(), который и делает их вызываемыми подобно обычным функциям.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Открытые члены (или «члены public») — это члены структуры или класса,
к которым можно получить доступ извне этой же структуры или класса.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Закрытые члены (или «члены private») — это члены класса, доступ к которым имеют только другие члены этого же класса.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Инкапсуляция (или «сокрытие информации») — это процесс скрытого хранения деталей реализации объекта.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Функция доступа — это короткая открытая функция, задачей которой является получение
или изменение значения закрытой переменной-члена класса.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Геттеры — это функции, которые возвращают значения закрытых переменных-членов класса.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Сеттеры — это функции, которые позволяют присваивать значения закрытым переменным-членам класса
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Конструктор — это особый тип метода класса, который автоматически вызывается при создании объекта этого же класса.
Конструкторы обычно используются для инициализации переменных-членов класса значениями,
которые предоставлены по умолчанию/пользователем, или для выполнения любых шагов настройки,
необходимых для используемого класса (например, открыть определенный файл или базу данных).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Деструктор — это специальный тип метода класса, который выполняется при удалении объекта класса. В то время как
конструкторы предназначены для инициализации класса, деструкторы предназначены для очистки памяти после него.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Идиома RAII (англ. «Resource Acquisition Is Initialization» = «Получение ресурсов есть инициализация») — это
идиома объектно-ориентированного программирования, при которой использование ресурсов привязывается к времени
жизни объектов с автоматической продолжительностью жизни.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Указатель *this — это скрытый константный указатель, содержащий адрес объекта, который вызывает метод класса.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Константный метод — это метод, который гарантирует, что не будет изменять объект или вызывать неконстантные
методы класса (поскольку они могут изменить объект).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Дружественная функция — это функция, которая имеет доступ к закрытым членам класса,
как если бы она сама была членом этого класса.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Анонимный объект — это значение без имени. Поскольку имени нет, то и способа ссылаться на этот объект за пределами места,
где он создан — тоже нет. Следовательно, анонимные объекты имеют область видимости выражения и они создаются,
обрабатываются и уничтожаются в пределах одного выражения.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Функторы (или «функциональные объекты») — классы, которые работают как функции.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Конструктор копирования — это особый тип конструктора, который используется для
создания нового объекта через копирование существующего объекта.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Контейнерный класс (или «класс-контейнер») в языке C++ — это класс, предназначенный для хранения и
организации нескольких объектов определенного типа данных (пользовательских или фундаментальных).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Контейнеры значения — это композиции, которые хранят копии объектов
(и, следовательно, ответственные за создание/уничтожение этих копий).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Контейнеры ссылки — это агрегации, которые хранят указатели или ссылки на другие объекты
(и, следовательно, не ответственные за создание/уничтожение этих объектов).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Таблица поиска — это массив, который содержит все предопределенные атрибуты (свойства) чего-либо.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Виртуальная функция в языке С++ — это особый тип функции, которая, при её вызове, выполняет «наиболее» дочерний метод,
который существует между родительским и дочерними классами. Это свойство еще известно, как полиморфизм. Дочерний
метод вызывается тогда, когда совпадает сигнатура (имя, типы параметров и является ли метод константным) и тип возврата
дочернего метода с сигнатурой и типом возврата метода родительского класса. Такие методы
называются переопределениями (или «переопределенными методами»).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Связывание — это процесс, который используется для конвертации идентификаторов
(таких как имена переменных или функций) в адреса.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Прямой вызов функции — это стейтмент, который напрямую вызывает функцию.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Раннее связывание (или «статическая привязка») — это означает, что компилятор (или линкер) может напрямую связать
имя идентификатора (например, имя функции или переменной) с машинным адресом.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Позднее связывание (или «динамическая привязка») — это когда в некоторых программах невозможно
знать наперёд, какая функция будет вызываться первой.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Виртуальная таблица в языке С++ — это таблица поиска функций для выполнения вызовов функций в режиме позднего (динамического)
связывания. Виртуальную таблицу еще называют «vtable», «таблицей виртуальных функций» или «таблицей виртуальных методов».
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Интерфейс — это класс, который не имеет переменных-членов и все методы которого являются чистыми виртуальными функциями!
Интерфейсы еще называют «классами-интерфейсами» или «интерфейсными классами».
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Виртуальный базовый класс — это класс, объект которого является общим для использования всеми дочерними классами.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Шаблоны функций — это функции, которые служат образцом для создания других подобных функций.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Параметр non-type в шаблоне — это специальный параметр шаблона, который заменяется не типом данных, а конкретным значением.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Спецификации исключений — это механизм объявления функций с указанием того, будет ли функция
генерировать исключения (и какие именно) или нет.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Класс-Исключение — это обычный класс, который выбрасывается в качестве исключения.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Умный указатель — это класс, предназначенный для управления динамически выделенной памятью и обеспечения освобождения
(удаления) выделенной памяти при выходе объекта этого класса из области видимости.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Циклическая зависимость (или «циклические ссылки») — это серия «ссылок», где текущий объект ссылается на следующий, а
последний объект ссылается на первый. Эти «ссылки» не обязательно должны быть обычными ссылками в языке C++, они
могут быть указателями, уникальными ID или любыми другими средствами идентификации конкретных объектов.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Последовательные контейнеры (или «контейнеры последовательности») — это контейнерные классы, элементы которых находятся в
последовательности. Их определяющей характеристикой является то, что вы можете добавить свой элемент в любое место контейнера.
Наиболее распространенным примером последовательного контейнера является массив: при добавлении 4-х элементов в массив,
эти элементы будут находиться (в массиве) в точно таком же порядке, в котором вы их добавили.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Ассоциативные контейнеры — это контейнерные классы, которые автоматически сортируют все свои элементы (в том числе и те,
которые добавляете вы). По умолчанию ассоциативные контейнеры выполняют сортировку элементов, используя оператор сравнения <.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Адаптеры — это специальные предопределенные контейнерные классы, которые адаптированы для выполнения конкретных заданий.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Итератор — это объект, который способен перебирать элементы контейнерного класса без необходимости пользователю знать
реализацию определенного контейнерного класса. Во многих контейнерах (особенно в списке и в ассоциативных контейнерах)
итераторы являются основным способом доступа к элементам этих контейнеров.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Поток — это последовательность символов, к которым можно получить доступ. Со временем поток может производить или
потреблять потенциально неограниченные объемы данных.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Стандартный поток — это предварительно подключенный поток, который предоставляется программе её окружением.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Манипулятор — это объект, который применяется для изменения потока данных с использованием
операторов извлечения (>>) или вставки (<<).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Группа форматирования — это группа флагов, которые задают аналогичные
(иногда взаимоисключающие) параметры форматирования вывода.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Валидация пользовательского ввода — это процесс проверки того, соответствует ли пользовательский ввод заданным критериям.
Обычно, валидация ввода бывает числовой и строковой.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Статическая библиотека (или «архив») состоит из подпрограмм, которые непосредственно
компилируются и линкуются с вашей программой.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Динамическая библиотека (или «общая библиотека») состоит из подпрограмм, которые
подгружаются в вашу программу во время её выполнения.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Библиотека импорта (англ. «import library») — это библиотека, которая автоматизирует
процесс подключения и использования динамической библиотеки.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Спецификации исключений — это механизм языка C++, который изначально был разработан для документирования в пределах
объявления функции того, какие исключения она может выбрасывать.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Гарантии безопасности исключений — это договоренности о том, как функции
или классы будут вести себя в случае возникновения исключений.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Структуры данных — это набор данных и методов для доступа и манипулирования этими данными.
Наиболее распространенной структурой данных, используемой в программировании, является массив,
который содержит ряд последовательных элементов одного типа.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Алгоритм — это последовательность операций для манипулирования данными с целью получения определенного результата.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Сеть (в широком смысле этого слова) — это подключение вашей программы к другим программам на вашем
компьютере или на других компьютерах, подключенных к сети, для обмена информацией.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~